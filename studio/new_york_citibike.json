{
  "components": [
    {
      "alias": "bikes",
      "name": "bikes",
      "purpose": "source",
      "type": "trilogy",
      "url": "https://trilogy-data.github.io/trilogy-public-models/trilogy_public_models/bigquery/new_york_citibike/bikes.preql"
    },
    {
      "alias": "entrypoint",
      "name": "entrypoint",
      "purpose": "entrypoint",
      "type": "trilogy",
      "url": "https://trilogy-data.github.io/trilogy-public-models/trilogy_public_models/bigquery/new_york_citibike/entrypoint.preql"
    },
    {
      "alias": "riders",
      "name": "riders",
      "purpose": "source",
      "type": "trilogy",
      "url": "https://trilogy-data.github.io/trilogy-public-models/trilogy_public_models/bigquery/new_york_citibike/riders.preql"
    },
    {
      "alias": "stations",
      "name": "stations",
      "purpose": "source",
      "type": "trilogy",
      "url": "https://trilogy-data.github.io/trilogy-public-models/trilogy_public_models/bigquery/new_york_citibike/stations.preql"
    },
    {
      "alias": "trips",
      "name": "trips",
      "purpose": "source",
      "type": "trilogy",
      "url": "https://trilogy-data.github.io/trilogy-public-models/trilogy_public_models/bigquery/new_york_citibike/trips.preql"
    }
  ],
  "description": "# NYC Citibike Dataset\n\n\n\n## Examples\nThis example walks through an [existing analysis](https://fitriwidyan.medium.com/nyc-citi-bike-trips-data-analysis-a07a1db9c1be) of New York Citibike usage, \nbut writes out the queries in trilogy. The full code can be found in the script.preql\nsection in this folder.\n\nFor this kind of one-off analysis, the queries should look quite similar. Note that the\ntrilogy examples are intended to be run sequentially as they define a few concepts\nthat are re-used in later queries. \n\n\n## Comparisons\n\n### Basic Select\nThe first query counts bikes in the system by year.\n\nSQL:\n```sql\nSELECT \n    EXTRACT(YEAR FROM starttime) AS year, \n    COUNT(DISTINCT(bikeid)) AS num_bikes\nFROM `bigquery-public-data.new_york_citibike.citibike_trips`\nGROUP BY year\nORDER BY year;\n```\n\nIn preql, we already have a bike.count metric defined in the public model, \nso we'll reference that and derive the year from the start time.\nThese queries are similar. \n\nPreQL:\n```sql\nproperty `trip.year<-year(trip.start_time)`;\n\nSELECT\n\ttrip.year,\n\tbike.count\nORDER BY\n    trip.year asc\nlimit 100;\n```\n\n### Case Statement\n\nNext we'll look at travel by 'generation'. Since we haven't implemented trilogy case/switch statements yet,\nthis gets a bit hacky.\n\n```sql\nWITH new_view AS(\n SELECT birth_year,\n CASE WHEN birth_year BETWEEN 1883 AND 1900 THEN \u2018Lost Generation\u2019\n      WHEN birth_year BETWEEN 1901 AND 1927 THEN \u2018G.I. Generation\u2019\n      WHEN birth_year BETWEEN 1928 AND 1945 THEN \u2018Silent Generation\u2019         \n      WHEN birth_year BETWEEN 1946 AND 1964 THEN \u2018Baby Boomers\u2019\n      WHEN birth_year BETWEEN 1965 AND 1980 THEN \u2018Generation X\u2019\n      WHEN birth_year BETWEEN 1981 AND 1996 THEN \u2018Millenials'         \n      WHEN birth_year BETWEEN 1997 AND 2012 THEN \u2018Generation Z' \n      ELSE 'Other'\n    END AS generation\n  FROM `bigquery-public-data.new_york_citibike.citibike_trips`)\nSELECT COUNT(birth_year) AS users, generation\nFROM new_view\nGROUP BY generation\nORDER BY users DESC;\n```\n\nIn trilogy we'll define a new property of the birth year for the generation,\nthen provide a datasource off a query as our source.\n```preql\nproperty trip.rider.birth_year.generation string;\n\ndatasource generations (\n    birth_year:trip.rider.birth_year,\n    CASE WHEN birth_year BETWEEN 1883 AND 1900 THEN 'Lost Generation'\n      WHEN birth_year BETWEEN 1901 AND 1927 THEN 'G.I. Generation'\n      WHEN birth_year BETWEEN 1928 AND 1945 THEN 'Silent Generation'\n      WHEN birth_year BETWEEN 1946 AND 1964 THEN 'Baby Boomers'\n      WHEN birth_year BETWEEN 1965 AND 1980 THEN 'Generation X'\n      WHEN birth_year BETWEEN 1981 AND 1996 THEN 'Millenials'\n      WHEN birth_year BETWEEN 1997 AND 2012 THEN 'Generation Z'\n      ELSE 'other'\n      END: generation\n    )\ngrain()\naddress `bigquery-public-data.new_york_citibike.citibike_trips`;\n\nselect\n    generation,\n    trip.count\norder by\n    trip.count desc;\n```\n\n### Stations by 2016 trips\n\nThis sql find the number of rides that started from given stations\nby a subscriber in 2016.\n\n```sql\nSELECT start_station_name, num_station\nFROM \n  (SELECT start_station_name, COUNT(start_station_name) AS       \n   num_station, EXTRACT(YEAR FROM starttime) AS year\n   FROM `bigquery-public-data.new_york_citibike.citibike_trips`\n   WHERE usertype = 'Subscriber'\n   GROUP BY start_station_name,year\n   ORDER BY year)\nWHERE year = 2016\nORDER BY num_station DESC\nLIMIT 10\n```\n\n\nIn preql, we'll reuse the year we already defined, filter to trips in that year\nwhere the type were subscriber, count those, and provide trip.start_station_name\nin the output to aggregate to that level. \n```sql\nkey subscriber_rides_2016 <- filter trip.start_time where trip.year=2016 and trip.user_type='Subscriber';\n\nmetric subscriber_ride_count_2016 <- count(subscriber_rides_2016);\n\nselect\n    trip.start_station_name,\n    subscriber_ride_count_2016,\norder by\n    subscriber_ride_count_2016 desc\nlimit 10;\n\n```\n\n\n### Bike Stats\n\n\n```sql\nSELECT bikeid, num_trip, duration, ROUND((duration/num_trip), 2) AS avg_duration_trip\nFROM\n    (SELECT bikeid, SUM(tripduration) AS duration, COUNT(*) AS    \n     num_trip\n     FROM `bigquery-public-data.new_york_citibike.citibike_trips`\n     WHERE bikeid IS NOT NULL\n     GROUP BY bikeid\n     ORDER BY duration DESC)\nLIMIT 10;\n```\n\nWe have a few of these defined in our public model, so the only additional\none is average trip duration. Then this is a striaghtforward select -\nno nesting required.\n```preql\nmetric trip.avg_duration <- trip.total_duration / trip.count;\n\nselect\n    bike.id,\n    trip.count,\n    trip.total_duration,\n    trip.avg_duration,\norder by\n    trip.total_duration desc\nlimit 10;\n```\n\n### Rides by Gender\n\nRides by gender is straightforward in SQL.\n```sql\nSELECT EXTRACT(YEAR FROM starttime) AS year,\n       COUNT(CASE WHEN gender = \u2018female\u2019 THEN 1 END ) AS \n       count_female,\n       COUNT(CASE WHEN gender = \u2018male\u2019 THEN 1 END ) AS count_male\nFROM `bigquery-public-data.new_york_citibike.citibike_trips`\nGROUP BY year\nORDER BY year;\n```\n\nWe'll highlight two strategies to answer this.\nWe can either define a generic aggregation - male_trips - that can be created at any grain,\nor define a property of year that is the output of aggregating to that level in a query.\n\nFor this query, those produce identical outcomes - but if you reuse the concepts later \non you\n```preql\nproperty male_trip  <- filter trip.start_time where rider.gender = 'male';\nproperty female_trip <- filter trip.start_time where rider.gender = 'female';\n\n# we can either define an arbitrary grain metric here, that can be aggregated\n# to any possible grain later (like trip.month)\nmetric male_trips <- count(male_trip);\nmetric female_trips <- count(female_trip);\n\n# or create a new property of the year implicitly via a select query. \n\nselect\n    trip.year,\n    count(male_trip)-> yearly_male_trips,\n    count(female_trip) -> yearly_female_trips\norder by\n    trip.year\n    asc;\n\nproperty trip.month <- month(trip.start_time);\n\nselect\n    trip.year,\n    trip.month,\n    male_trips,\n    female_trips,\n    male_trips / yearly_male_trips -> percent_of_yearly_total_male_trips,\n    female_trips /yearly_female_trips -> percent_of_yearly_total_female_trips\n  \nwhere trip.year = 2018\norder by trip.month desc;\n```\n\n## Subscriber\n\nSubscriber query is straightforward.\n\n```sql\nSELECT EXTRACT(YEAR FROM starttime) AS year,\n       COUNT(CASE WHEN usertype = \u2018Subscriber\u2019 THEN 1 END ) AS\n       count_subscriber,\n       COUNT(CASE WHEN usertype = \u2018Customer\u2019 THEN 1 END ) AS    \n       count_customer\nFROM `bigquery-public-data.new_york_citibike.citibike_trips`\nGROUP BY year\nORDER BY year;\n```\n\n\n```sql\n\nproperty subscriber_trip <- filter trip.start_time where trip.user_type = 'Subscriber';\nproperty customer_trip <- filter trip.start_time where trip.user_type = 'Customer';\n\nselect \n    trip.year,\n    count(trip.start_time) -> yearly_trips,\n    count(subscriber_trip) -> yearly_subscriber_trips,\n    count(customer_trip) -> yearly_customer_trips\norder by \n    trip.year asc;\n   \n```\n\n\n## Trip Growth\n\nCalculating trip growth shows how to use window functions, such as lag/lead. \n\n```sql\nSELECT year, trip, previous, trip-previous AS trip_growth, \n       ROUND((trip-previous)/previous*100, 2) AS \n       percentage_trip_growth\nFROM (SELECT year, trip, LAG(trip) OVER (ORDER BY year) AS previous\n  FROM (SELECT EXTRACT(YEAR FROM starttime) AS year,\n        COUNT(start_station_id) AS trip\n        FROM `bigquery-public-data.new_york_citibike.citibike_trips`\n        GROUP BY year)\n  WHERE year IS NOT NULL\n  GROUP BY year, trip\n  ORDER BY year)\nORDER BY year\n\n\n```\n\n\n```sql\nmetric lagging_yearly_trips <- lag yearly_trips by trip.year asc;\nmetric yoy_trip_growth <- yearly_trips - lagging_yearly_trips;\nmetric yoy_growth_ratio <- round(yoy_trip_growth / lagging_yearly_trips * 100 ,2);\n\nselect\n    trip.year,\n    yearly_trips,\n    lagging_yearly_trips,\n    yoy_trip_growth,\n    yoy_growth_ratio\norder by \n    trip.year asc;\n```",
  "engine": "bigquery",
  "link": "",
  "name": "new_york_citibike",
  "tags": [
    "bigquery"
  ]
}